// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

#ifndef GT_LIGHTING_UNREAL
#define GT_LIGHTING_UNREAL

#include "Common/GTLighting.ush"

// Based on Engine/Shaders/Private/ReflectionEnvironmentShared.ush GetSkySHDiffuse
Half3 GTGetSkySHDiffuse(Half3 Normal)
{
    Half4 NormalVector = Half4(Normal, 1);

    Half3 Intermediate0;
    Intermediate0.x = dot(View.SkyIrradianceEnvironmentMap[0], NormalVector);
    Intermediate0.y = dot(View.SkyIrradianceEnvironmentMap[1], NormalVector);
    Intermediate0.z = dot(View.SkyIrradianceEnvironmentMap[2], NormalVector);

    // Max to avoid negative colors.
    return max(0, Intermediate0);
}

// Based on Engine/Shaders/Private/MobileBasePassPixelShader.usf MobileComputeMixingWeight3
Half3 GTComputeMixingWeight(Half IndirectIrradiance,
                            Half RoughnessSq)
{
    // Mirror surfaces should have no mixing, so they match reflections from other sources (SSR, planar reflections).
    Half MixingAlpha = smoothstep(0, 1, saturate(RoughnessSq * View.ReflectionEnvironmentRoughnessMixingScaleBiasAndLargestWeight.x + View.ReflectionEnvironmentRoughnessMixingScaleBiasAndLargestWeight.y));

    // We have high frequency directional data but low frequency spatial data in the envmap.
    // We have high frequency spatial data but low frequency directional data in the lightmap.
    // So, we combine the two for the best of both. This is done by removing the low spatial frequencies from the envmap and replacing them with the lightmap data.
    // This is only done with luma so as to not get odd color shifting.
    Half3 MixingWeight = Half3(IndirectIrradiance, IndirectIrradiance, IndirectIrradiance);
    MixingWeight = min(MixingWeight, Half3(View.ReflectionEnvironmentRoughnessMixingScaleBiasAndLargestWeight.z,
                                           View.ReflectionEnvironmentRoughnessMixingScaleBiasAndLargestWeight.z,
                                           View.ReflectionEnvironmentRoughnessMixingScaleBiasAndLargestWeight.z));

    return lerp(Half3(1, 1, 1), MixingWeight, MixingAlpha);
}

Half3 GTContributionDefaultLit(FMaterialPixelParameters Parameters,
                               float3 BaseColor,
                               float Metallic,
                               float Specular,
                               float Roughness,
                               float3 Normal,
                               float AmbientOcclusion,
                               TextureCube ReflectionCube,
                               SamplerState ReflectionCubeSampler,
                               float DirectLightIntensity,
                               float4 DirectionalLightDirectionEnabled,
                               float4 DirectionalLightColorIntensity)
{
    Half RoughnessSq = clamp(Roughness * Roughness, GT_MIN_N_DOT_V, 1.0);

    Half3 Result = Half3(0, 0, 0);

#if !GT_FULLY_ROUGH
    // Indirect (spherical harmonics)
    Half3 SkySHDiffuse = GTGetSkySHDiffuse(Normal);
    Result += GTContributionSH(BaseColor,
                               Metallic,
                               Roughness,
                               SkySHDiffuse,
                               ResolvedView.SkyLightColor.rgb);

    // Indirect (reflection cube).
    Half3 MixingWeight = GTComputeMixingWeight(GTLuminance(SkySHDiffuse) * AmbientOcclusion,
                                               RoughnessSq);
    Result += GTContributionReflection(BaseColor,
                                       RoughnessSq,
                                       ReflectionCube,
                                       ReflectionCubeSampler,
                                       Parameters.ReflectionVector * Parameters.TwoSidedSign,
                                       MixingWeight);

#endif // GT_FULLY_ROUGH

    if (DirectionalLightDirectionEnabled.w != 0)
    {
        // Direct (directional light).
        Result += GTContributionDirectionalLight(BaseColor,
                                                 Metallic,
                                                 Roughness,
                                                 RoughnessSq,
                                                 Specular,
                                                 Normal,
                                                 Parameters.CameraVector,
                                                 DirectionalLightDirectionEnabled.xyz,
                                                 DirectionalLightColorIntensity) * DirectLightIntensity;
    }

    return Result * AmbientOcclusion;
}

#endif // GT_LIGHTING_UNREAL