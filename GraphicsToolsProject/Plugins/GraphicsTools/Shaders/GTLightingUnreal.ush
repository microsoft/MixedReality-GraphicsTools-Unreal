// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

// PBR Lighting modeled from: https://google.github.io/filament/Filament.html

#ifndef GT_LIGHTING_UNREAL
#define GT_LIGHTING_UNREAL

#include "Common/GTLighting.ush"

#define PI 3.14159265359
#define MEDIUMP_FLT_MAX 65504.0

#define REFLECTION_CUBE_MAX_MIP 10

#define MIN_N_DOT_V 1e-4

float clampNoV(float NoV)
{
    // Neubelt and Pettineo 2013, "Crafting a Next-gen Material Pipeline for The Order: 1886"
    return max(NoV, MIN_N_DOT_V);
}

float D_GGX2(float roughness, float NoH, float3 NxH)
{
    float oneMinusNoHSquared = dot(NxH, NxH);

    float a = NoH * roughness;
    float k = roughness / (oneMinusNoHSquared + a * a);
    float d = k * k * (1.0 / PI);
    return min(d, MEDIUMP_FLT_MAX);
}

float distribution(float roughness, float NoH, float3 NxH)
{
    return D_GGX2(roughness, NoH, NxH);
}

float V_SmithGGXCorrelated_Fast(float roughness, float NoV, float NoL)
{
    // Hammon 2017, "PBR Diffuse Lighting for GGX+Smith Microsurfaces"
    float v = 0.5 / lerp(2.0 * NoL * NoV, NoL + NoV, roughness);
    return v;
}

float visibility(float roughness, float NoV, float NoL)
{
    return V_SmithGGXCorrelated_Fast(roughness, NoV, NoL);
}

float3 F_SchlickGT(const float3 f0, float LoH)
{
    float f = pow(1.0 - LoH, 5.0);
    return f + f0 * (1.0 - f);
}

float3 fresnel(const float3 f0, float LoH)
{
    return F_SchlickGT(f0, LoH); // f90 = 1.0
}

float3 specularLobe(float roughness, float NoV, float NoL, float NoH, float LoH, float3 NxH, float3 f0)
{
    float D = distribution(roughness, NoH, NxH);
    float V = visibility(roughness, NoV, NoL);
    float3 F = fresnel(f0, LoH);

    return (D * V) * F;
}

float Fd_Lambert()
{
    return 1.0 / PI;
}

float3 diffuseLobe(float3 diffuseColor)
{
    return diffuseColor * Fd_Lambert();
}



float3 GetSkySHDiffuseSimpleGT(float3 Normal)
{
    float4 NormalVector = float4(Normal, 1);

    float3 Intermediate0;
    Intermediate0.x = dot(View.SkyIrradianceEnvironmentMap[0], NormalVector);
    Intermediate0.y = dot(View.SkyIrradianceEnvironmentMap[1], NormalVector);
    Intermediate0.z = dot(View.SkyIrradianceEnvironmentMap[2], NormalVector);

    // max to not get negative colors
    return max(0, Intermediate0);
}

Half3 MobileComputeMixingWeight3GT(Half IndirectIrradiance, Half Roughness)
{
    // Mirror surfaces should have no mixing, so they match reflections from other sources (SSR, planar reflections)
    Half MixingAlpha = smoothstep(0, 1, saturate(Roughness * View.ReflectionEnvironmentRoughnessMixingScaleBiasAndLargestWeight.x + View.ReflectionEnvironmentRoughnessMixingScaleBiasAndLargestWeight.y));

    // We have high frequency directional data but low frequency spatial data in the envmap.
    // We have high frequency spatial data but low frequency directional data in the lightmap.
    // So, we combine the two for the best of both. This is done by removing the low spatial frequencies from the envmap and replacing them with the lightmap data.
    // This is only done with luma so as to not get odd color shifting.
    Half3 MixingWeight = Half3(IndirectIrradiance, IndirectIrradiance, IndirectIrradiance);
    MixingWeight = min(MixingWeight, Half3(View.ReflectionEnvironmentRoughnessMixingScaleBiasAndLargestWeight.z, View.ReflectionEnvironmentRoughnessMixingScaleBiasAndLargestWeight.z, View.ReflectionEnvironmentRoughnessMixingScaleBiasAndLargestWeight.z));

    return lerp(Half3(1.0f, 1.0f, 1.0f), MixingWeight, MixingAlpha);
}

Half3 GTIndirectLighting(float3 baseColor, float metallic, float roughness, float roughnessSq, TextureCube reflectionCube, SamplerState reflectionCubeSampler, Half3 reflectionVector, Half3 skyDiffuseLighting, Half3 skyLightColor)
{
    float3 result = float3(0, 0, 0);

    // Indirect (spherical harmonics)
    result += (skyDiffuseLighting * skyLightColor * baseColor) * max(0.3, min(1 - metallic, 1 - roughness));

    // Indirect (reflection cube).
    Half lod = (REFLECTION_CUBE_MAX_MIP - 1) - (1 - 1.2 * log2(roughnessSq));
    Half3 specularIBL = reflectionCube.SampleLevel(reflectionCubeSampler, reflectionVector, lod).rgb * skyDiffuseLighting;
    Half3 diffuseLookup = skyDiffuseLighting * skyLightColor;
    specularIBL *= MobileComputeMixingWeight3GT(GTLuminance(diffuseLookup), roughness);
    result += specularIBL * baseColor * 2;

	return result;
}

float3 DefaultLit(FMaterialPixelParameters Parameters, float3 BaseColor, float Metallic, float Roughness, float Specular, TextureCube ReflectionCube, SamplerState ReflectionCubeSampler)
{
    float3 LightDirection = float3(-0.73, 0.0, 0.68); //MobileDirectionalLight.DirectionalLightDirectionAndShadowTransition.xyz
    float3 WorldNormal = normalize(Parameters.WorldNormal);
    float3 LightColor = float3(1, 1, 1); //MobileDirectionalLight.DirectionalLightColor.rgb
    float3 CameraVector = Parameters.CameraVector;

    float RoughnessSq = clamp(Roughness * Roughness, MIN_N_DOT_V, 1.0);

    float3 Result = float3(0, 0, 0);

    Result += GTIndirectLighting(BaseColor, Metallic, Roughness, RoughnessSq, ReflectionCube, ReflectionCubeSampler, Parameters.ReflectionVector, GetSkySHDiffuseSimpleGT(WorldNormal), ResolvedView.SkyLightColor.rgb);

    // Direct
    float3 h = normalize(CameraVector + LightDirection);
    float NoV = clampNoV(dot(WorldNormal, CameraVector));
    float NoL = saturate(dot(WorldNormal, LightDirection));
    float NoH = saturate(dot(WorldNormal, h));
    float LoH = saturate(dot(LightDirection, h));
    float3 NxH = cross(WorldNormal, h);
    float3 f0 = 0.16 * Specular * Specular * (1.0 - Metallic) + BaseColor * Metallic;
    float3 Fr = specularLobe(RoughnessSq, NoV, NoL, NoH, LoH, NxH, f0);
    float3 Fd = diffuseLobe(BaseColor * max(1 - Metallic, Roughness));

    Result += ((Fd + Fr) * LightColor) * NoL * (1 + (1 - Metallic));

    return Result;
}

#endif // GT_LIGHTING_UNREAL